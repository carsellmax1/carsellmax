import { NextRequest, NextResponse } from 'next/server';
import { createClient } from '@supabase/supabase-js';

interface CarSubmissionData {
  // Customer information
  customer: {
    name: string;
  email: string;
  phone: string;
    address: {
      street: string;
  city: string;
  state: string;
      zip: string;
    };
  };
  
  // Vehicle information
  vehicle: {
  make: string;
  model: string;
    year: number;
    mileage: number;
  vin?: string;
  color: string;
  condition: string;
    additional_notes?: string;
  };
  
  // Valuation information
  valuation: {
    estimated_value: number;
    market_data?: any;
  };
  
  // Photos
  photos: Array<{
    category: string;
    filename: string;
    size: number;
    type: string;
  }>;
}

// Comprehensive submission data interface
interface ComprehensiveSubmissionData {
  userDetails: {
    firstName: string;
    lastName: string;
    email: string;
    phone: string;
  };
  vehicleDetails: {
    condition: string;
    interiorColor: string;
    driveTrain: string;
    exteriorColor: string;
    transmission: string;
    fuelType: string;
    additionalInfo: string;
  };
  exteriorImages: Record<string, string | null>;
  interiorImages: Record<string, string | null>;
  engineVideo: {
    engineVideo: string | null;
    engineSound: string | null;
    additionalVideos: string[];
    notes: string;
  };
  carData: {
    vin: string;
    make_model: string;
    year: string;
    color: string;
    type: string;
    fuel: string;
    mileage: string;
    image_url: string | null;
    estimated_value: number;
  };
}

// Disposable email domains (basic list)
const DISPOSABLE_EMAIL_DOMAINS = [
  '10minutemail.com', 'tempmail.org', 'guerrillamail.com', 'mailinator.com',
  'throwaway.email', 'temp-mail.org', 'sharklasers.com', 'grr.la'
];

// Rate limiting (in-memory for demo - use Redis in production)
const rateLimitMap = new Map<string, { count: number; resetTime: number }>();
const RATE_LIMIT_WINDOW = 15 * 60 * 1000; // 15 minutes
const RATE_LIMIT_MAX_REQUESTS = 3; // 3 requests per 15 minutes per IP

// Rate limiting function
function checkRateLimit(ip: string): boolean {
  const now = Date.now();
  const userLimit = rateLimitMap.get(ip);
  
  if (!userLimit || now > userLimit.resetTime) {
    rateLimitMap.set(ip, { count: 1, resetTime: now + RATE_LIMIT_WINDOW });
    return true;
  }
  
  if (userLimit.count >= RATE_LIMIT_MAX_REQUESTS) {
    return false;
  }
  
  userLimit.count++;
  return true;
}

// Disposable email check
function isDisposableEmail(email: string): boolean {
  const domain = email.split('@')[1]?.toLowerCase();
  return DISPOSABLE_EMAIL_DOMAINS.includes(domain || '');
}

// VIN validation
function isValidVIN(vin: string): boolean {
  if (!vin || vin.length !== 17) return false;
  return /^[A-HJ-NPR-Z0-9]{17}$/.test(vin);
}

export async function POST(request: NextRequest) {
  try {
    const clientIP = request.headers.get('x-forwarded-for') || 
                     request.headers.get('x-real-ip') || 
                     'unknown';

    // Rate limiting check
    if (!checkRateLimit(clientIP)) {
      return NextResponse.json(
        { error: 'Too many requests. Please try again later.' },
        { status: 429 }
      );
    }

    const rawData = await request.json();
    
    // Check if this is comprehensive submission data
    const isComprehensive = rawData.userDetails && rawData.vehicleDetails && rawData.exteriorImages && rawData.carData;
    
    if (isComprehensive) {
      return handleComprehensiveSubmission(rawData as ComprehensiveSubmissionData, clientIP);
    } else {
      return handleLegacySubmission(rawData as CarSubmissionData, clientIP);
    }

  } catch (error) {
    console.error('Car submission error:', error);
    return NextResponse.json(
      { error: 'Failed to submit car information. Please try again.' },
      { status: 500 }
    );
  }
}

async function handleComprehensiveSubmission(data: ComprehensiveSubmissionData, clientIP: string) {
  try {
    const { userDetails, vehicleDetails, exteriorImages, interiorImages, engineVideo, carData } = data;

    // Initialize Supabase client
    const supabaseUrl = 'https://xjiymlzvbvjzdujvgcwc.supabase.co';
    const supabaseKey = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6InhqaXltbHp2YnZqemR1anZnY3djIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NTgzMzgyODksImV4cCI6MjA3MzkxNDI4OX0.Sxuqx6dsSGnUHcLXsffdIocjpEuBdxHtDkJNA7PKZB0';
    const supabase = createClient(supabaseUrl, supabaseKey);

    // Use actual user details from the form
    let customerData = {
      name: `${userDetails.firstName} ${userDetails.lastName}`,
      email: userDetails.email,
      phone: userDetails.phone,
      address: {
        street: 'N/A', // Not collected in current form
        city: 'N/A',
        state: 'N/A',
        zip: 'N/A'
      }
    };

    // Check for existing customer or create new one
    const { data: existingCustomer } = await supabase
      .from('customers')
      .select('*')
      .eq('email', customerData.email)
      .eq('org_id', '00000000-0000-0000-0000-000000000001')
      .single();

    if (existingCustomer) {
      // Update existing customer with new information
      const { data: updatedCustomer, error: updateError } = await supabase
        .from('customers')
        .update({
          name: customerData.name,
          phone: customerData.phone,
          address: customerData.address,
          updated_at: new Date().toISOString()
        })
        .eq('id', existingCustomer.id)
        .select()
        .single();

      if (updateError) {
        console.error('Customer update error:', updateError);
        return NextResponse.json(
          { error: 'Failed to update customer record' },
          { status: 500 }
        );
      }
      customerData = updatedCustomer;
    } else {
      // Create new customer
      const { data: newCustomer, error: customerError } = await supabase
        .from('customers')
        .insert([{
          name: customerData.name,
          email: customerData.email,
          phone: customerData.phone,
          address: customerData.address,
          org_id: '00000000-0000-0000-0000-000000000001'
        }])
        .select()
        .single();

      if (customerError) {
        console.error('Customer creation error:', customerError);
        return NextResponse.json(
          { error: 'Failed to create customer record' },
          { status: 500 }
        );
      }
      customerData = newCustomer;
    }

    // Check for existing vehicle or create new one
    let vehicleData;
    if (carData.vin) {
      const { data: existingVehicle } = await supabase
        .from('vehicles')
        .select('*')
        .eq('vin', carData.vin)
        .eq('org_id', '00000000-0000-0000-0000-000000000001')
        .single();

      if (existingVehicle) {
        // Update existing vehicle with new information
        const { data: updatedVehicle, error: updateError } = await supabase
          .from('vehicles')
          .update({
            make: carData.make_model.split(' ')[0] || 'Unknown',
            model: carData.make_model.split(' ').slice(1).join(' ') || 'Unknown',
            year: parseInt(carData.year),
            mileage: parseInt(carData.mileage.replace(/,/g, '')),
            color: carData.color,
            condition: vehicleDetails.condition,
            transmission: vehicleDetails.transmission,
            fuel_type: vehicleDetails.fuelType,
            body_type: carData.type,
            interior_color: vehicleDetails.interiorColor,
            exterior_color: vehicleDetails.exteriorColor,
            drive_train: vehicleDetails.driveTrain,
            additional_info: vehicleDetails.additionalInfo,
            updated_at: new Date().toISOString()
          })
          .eq('id', existingVehicle.id)
          .select()
          .single();

        if (updateError) {
          console.error('Vehicle update error:', updateError);
          return NextResponse.json(
            { error: 'Failed to update vehicle record' },
            { status: 500 }
          );
        }
        vehicleData = updatedVehicle;
      } else {
        // Create new vehicle
        const { data: newVehicle, error: vehicleError } = await supabase
          .from('vehicles')
          .insert([{
            make: carData.make_model.split(' ')[0] || 'Unknown',
            model: carData.make_model.split(' ').slice(1).join(' ') || 'Unknown',
            year: parseInt(carData.year),
            vin: carData.vin,
            mileage: parseInt(carData.mileage.replace(/,/g, '')),
            color: carData.color,
            condition: vehicleDetails.condition,
            transmission: vehicleDetails.transmission,
            fuel_type: vehicleDetails.fuelType,
            body_type: carData.type,
            interior_color: vehicleDetails.interiorColor,
            exterior_color: vehicleDetails.exteriorColor,
            drive_train: vehicleDetails.driveTrain,
            additional_info: vehicleDetails.additionalInfo,
            org_id: '00000000-0000-0000-0000-000000000001'
          }])
          .select()
          .single();

        if (vehicleError) {
          console.error('Vehicle creation error:', vehicleError);
          return NextResponse.json(
            { error: 'Failed to create vehicle record' },
            { status: 500 }
          );
        }
        vehicleData = newVehicle;
      }
    } else {
      // Create new vehicle without VIN
      const { data: newVehicle, error: vehicleError } = await supabase
        .from('vehicles')
        .insert([{
          make: carData.make_model.split(' ')[0] || 'Unknown',
          model: carData.make_model.split(' ').slice(1).join(' ') || 'Unknown',
          year: parseInt(carData.year),
          vin: null,
          mileage: parseInt(carData.mileage.replace(/,/g, '')),
          color: carData.color,
          condition: vehicleDetails.condition,
          transmission: vehicleDetails.transmission,
          fuel_type: vehicleDetails.fuelType,
          body_type: carData.type,
          interior_color: vehicleDetails.interiorColor,
          exterior_color: vehicleDetails.exteriorColor,
          drive_train: vehicleDetails.driveTrain,
          additional_info: vehicleDetails.additionalInfo,
          org_id: '00000000-0000-0000-0000-000000000001'
        }])
        .select()
        .single();

      if (vehicleError) {
        console.error('Vehicle creation error:', vehicleError);
        return NextResponse.json(
          { error: 'Failed to create vehicle record' },
          { status: 500 }
        );
      }
      vehicleData = newVehicle;
    }

    // Create quote submission with comprehensive data
    const { data: quoteData, error: quoteError } = await supabase
      .from('quote_submissions')
      .insert([{
        customer_id: customerData.id,
        vehicle_id: vehicleData.id,
        estimated_value: carData.estimated_value,
        additional_notes: vehicleDetails.additionalInfo,
        status: 'pending_review',
        vehicle_condition_details: vehicleDetails,
        exterior_images: exteriorImages,
        interior_images: interiorImages,
        engine_videos: engineVideo,
        submission_step: 'completed',
        org_id: '00000000-0000-0000-0000-000000000001'
      }])
      .select()
      .single();

    if (quoteError) {
      console.error('Quote submission error:', quoteError);
      return NextResponse.json(
        { error: 'Failed to create quote submission' },
        { status: 500 }
      );
    }

    // Create media assets for images
    const mediaAssets = [];
    
    // Process exterior images
    for (const [position, imageData] of Object.entries(exteriorImages)) {
      if (imageData) {
        mediaAssets.push({
          quote_submission_id: quoteData.id,
          file_name: `${position}_exterior.jpg`,
          file_path: `/uploads/${quoteData.id}/exterior/${position}.jpg`,
          file_type: 'image',
          file_size: 0, // Base64 size calculation would go here
          mime_type: 'image/jpeg',
          category: 'exterior',
          image_type: 'exterior',
          image_position: position,
          is_required: ['front', 'rear', 'driverSide', 'passengerSide'].includes(position),
          org_id: '00000000-0000-0000-0000-000000000001'
        });
      }
    }

    // Process interior images
    for (const [position, imageData] of Object.entries(interiorImages)) {
      if (imageData) {
        mediaAssets.push({
          quote_submission_id: quoteData.id,
          file_name: `${position}_interior.jpg`,
          file_path: `/uploads/${quoteData.id}/interior/${position}.jpg`,
          file_type: 'image',
          file_size: 0,
          mime_type: 'image/jpeg',
          category: 'interior',
          image_type: 'interior',
          image_position: position,
          is_required: ['dashboard', 'frontSeats', 'odometer'].includes(position),
          org_id: '00000000-0000-0000-0000-000000000001'
        });
      }
    }

    // Process engine videos
    if (engineVideo.engineVideo) {
      mediaAssets.push({
        quote_submission_id: quoteData.id,
        file_name: 'engine_video.mp4',
        file_path: `/uploads/${quoteData.id}/videos/engine_video.mp4`,
        file_type: 'video',
        file_size: 0,
        mime_type: 'video/mp4',
        category: 'engine_video',
        image_type: 'engine_video',
        image_position: 'main',
        is_required: true,
        org_id: '00000000-0000-0000-0000-000000000001'
      });
    }

    if (engineVideo.engineSound) {
      mediaAssets.push({
        quote_submission_id: quoteData.id,
        file_name: 'engine_sound.mp3',
        file_path: `/uploads/${quoteData.id}/audio/engine_sound.mp3`,
        file_type: 'audio',
        file_size: 0,
        mime_type: 'audio/mpeg',
        category: 'engine_audio',
        image_type: 'engine_audio',
        image_position: 'main',
        is_required: false,
        org_id: '00000000-0000-0000-0000-000000000001'
      });
    }

    // Insert media assets
    if (mediaAssets.length > 0) {
      const { error: mediaError } = await supabase
        .from('media_assets')
        .insert(mediaAssets);

      if (mediaError) {
        console.error('Media assets error:', mediaError);
        // Don't fail the entire submission for media errors
      }
    }

    console.log('Comprehensive submission created successfully:', {
      submissionId: quoteData.id,
      publicToken: quoteData.public_token,
      vehicle: `${carData.year} ${carData.make_model}`,
      ip: clientIP,
      timestamp: new Date().toISOString()
    });

    return NextResponse.json({
      success: true,
      message: 'Your comprehensive submission has been received! Our team will review all the details and get back to you with a detailed offer.',
      public_token: quoteData.public_token,
      submission_id: quoteData.id,
      estimated_response_time: '24 hours'
    });

  } catch (error) {
    console.error('Comprehensive submission error:', error);
    return NextResponse.json(
      { error: 'Failed to submit comprehensive car information. Please try again.' },
      { status: 500 }
    );
  }
}

async function handleLegacySubmission(submissionData: CarSubmissionData, clientIP: string) {
  try {
    // Validate required fields
    if (!submissionData.customer || !submissionData.vehicle || !submissionData.valuation) {
      return NextResponse.json(
        { error: 'Invalid submission data structure' },
        { status: 400 }
      );
    }

    const { customer, vehicle, valuation, photos } = submissionData;

    // Validate customer data
    if (!customer.name || !customer.email || !customer.phone) {
      return NextResponse.json(
        { error: 'Missing required customer information' },
        { status: 400 }
      );
    }

    // Validate email format
    const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
    if (!emailRegex.test(customer.email)) {
      return NextResponse.json(
        { error: 'Invalid email format' },
        { status: 400 }
      );
    }

    // Check for disposable email
    if (isDisposableEmail(customer.email)) {
      return NextResponse.json(
        { error: 'Please use a valid email address' },
        { status: 400 }
      );
    }

    // Validate vehicle data
    if (!vehicle.make || !vehicle.model || !vehicle.year || !vehicle.mileage) {
      return NextResponse.json(
        { error: 'Missing required vehicle information' },
        { status: 400 }
      );
    }

    // Validate year
    const currentYear = new Date().getFullYear();
    if (vehicle.year < 1900 || vehicle.year > currentYear + 1) {
      return NextResponse.json(
        { error: 'Invalid vehicle year' },
        { status: 400 }
      );
    }

    // Validate mileage
    if (vehicle.mileage < 0 || vehicle.mileage > 999999) {
      return NextResponse.json(
        { error: 'Invalid mileage value' },
        { status: 400 }
      );
    }

    // Validate VIN if provided
    if (vehicle.vin && !isValidVIN(vehicle.vin)) {
      return NextResponse.json(
        { error: 'Invalid VIN format' },
        { status: 400 }
      );
    }

    // Initialize Supabase client
    const supabaseUrl = 'https://xjiymlzvbvjzdujvgcwc.supabase.co';
    const supabaseKey = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6InhqaXltbHp2YnZqemR1anZnY3djIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NTgzMzgyODksImV4cCI6MjA3MzkxNDI4OX0.Sxuqx6dsSGnUHcLXsffdIocjpEuBdxHtDkJNA7PKZB0';
    const supabase = createClient(supabaseUrl, supabaseKey);

    // Check for existing customer or create new one
    let customerData;
    const { data: existingCustomer } = await supabase
      .from('customers')
      .select('*')
      .eq('email', customer.email)
      .eq('org_id', '00000000-0000-0000-0000-000000000001')
      .single();

    if (existingCustomer) {
      // Update existing customer with new information
      const { data: updatedCustomer, error: updateError } = await supabase
        .from('customers')
        .update({
          name: customer.name,
          phone: customer.phone,
          address: customer.address,
          updated_at: new Date().toISOString()
        })
        .eq('id', existingCustomer.id)
        .select()
        .single();

      if (updateError) {
        console.error('Customer update error:', updateError);
        return NextResponse.json(
          { error: 'Failed to update customer record' },
          { status: 500 }
        );
      }
      customerData = updatedCustomer;
    } else {
      // Create new customer
      const { data: newCustomer, error: customerError } = await supabase
        .from('customers')
        .insert([{
          name: customer.name,
          email: customer.email,
          phone: customer.phone,
          address: customer.address,
          org_id: '00000000-0000-0000-0000-000000000001'
        }])
        .select()
        .single();

      if (customerError) {
        console.error('Customer creation error:', customerError);
        return NextResponse.json(
          { error: 'Failed to create customer record' },
          { status: 500 }
        );
      }
      customerData = newCustomer;
    }

    // Check for existing vehicle or create new one
    let vehicleData;
    if (vehicle.vin) {
      const { data: existingVehicle } = await supabase
        .from('vehicles')
        .select('*')
        .eq('vin', vehicle.vin)
        .eq('org_id', '00000000-0000-0000-0000-000000000001')
        .single();

      if (existingVehicle) {
        // Update existing vehicle with new information
        const { data: updatedVehicle, error: updateError } = await supabase
          .from('vehicles')
          .update({
            make: vehicle.make,
            model: vehicle.model,
            year: vehicle.year,
            mileage: vehicle.mileage,
            color: vehicle.color,
            condition: vehicle.condition,
            updated_at: new Date().toISOString()
          })
          .eq('id', existingVehicle.id)
          .select()
          .single();

        if (updateError) {
          console.error('Vehicle update error:', updateError);
          return NextResponse.json(
            { error: 'Failed to update vehicle record' },
            { status: 500 }
          );
        }
        vehicleData = updatedVehicle;
      } else {
        // Create new vehicle
        const { data: newVehicle, error: vehicleError } = await supabase
          .from('vehicles')
          .insert([{
            make: vehicle.make,
            model: vehicle.model,
            year: vehicle.year,
            vin: vehicle.vin,
            mileage: vehicle.mileage,
            color: vehicle.color,
            condition: vehicle.condition,
            org_id: '00000000-0000-0000-0000-000000000001'
          }])
          .select()
          .single();

        if (vehicleError) {
          console.error('Vehicle creation error:', vehicleError);
          return NextResponse.json(
            { error: 'Failed to create vehicle record' },
            { status: 500 }
          );
        }
        vehicleData = newVehicle;
      }
    } else {
      // Create new vehicle without VIN
      const { data: newVehicle, error: vehicleError } = await supabase
        .from('vehicles')
        .insert([{
          make: vehicle.make,
          model: vehicle.model,
          year: vehicle.year,
          vin: null,
          mileage: vehicle.mileage,
          color: vehicle.color,
          condition: vehicle.condition,
          org_id: '00000000-0000-0000-0000-000000000001'
        }])
        .select()
        .single();

      if (vehicleError) {
        console.error('Vehicle creation error:', vehicleError);
        return NextResponse.json(
          { error: 'Failed to create vehicle record' },
          { status: 500 }
        );
      }
      vehicleData = newVehicle;
    }

    // Create quote submission
    const { data: quoteData, error: quoteError } = await supabase
      .from('quote_submissions')
      .insert([{
        customer_id: customerData.id,
        vehicle_id: vehicleData.id,
        estimated_value: valuation.estimated_value,
        additional_notes: vehicle.additional_notes,
        status: 'pending_review',
        org_id: '00000000-0000-0000-0000-000000000001'
      }])
      .select()
      .single();

    if (quoteError) {
      console.error('Quote submission error:', quoteError);
      return NextResponse.json(
        { error: 'Failed to create quote submission' },
        { status: 500 }
      );
    }

    // Create media assets for photos
    if (photos && photos.length > 0) {
      const mediaAssets = photos.map(photo => ({
        quote_submission_id: quoteData.id,
        file_name: photo.filename,
        file_path: `/uploads/${quoteData.id}/${photo.filename}`, // Placeholder path
        file_type: photo.type,
        file_size: photo.size,
        mime_type: photo.type,
        category: photo.category,
        org_id: '00000000-0000-0000-0000-000000000001'
      }));

      const { error: mediaError } = await supabase
        .from('media_assets')
        .insert(mediaAssets);

      if (mediaError) {
        console.error('Media assets error:', mediaError);
        // Don't fail the entire submission for media errors
      }
    }

    // Log successful submission
    console.log('Car submission created successfully:', {
      submissionId: quoteData.id,
      publicToken: quoteData.public_token,
      customerEmail: customer.email,
      vehicle: `${vehicle.year} ${vehicle.make} ${vehicle.model}`,
      ip: clientIP,
      timestamp: new Date().toISOString()
    });

    return NextResponse.json({
      success: true,
      message: 'Your quote request has been submitted successfully! Our team will review it and get back to you within 24 hours.',
      public_token: quoteData.public_token,
      submission_id: quoteData.id,
      estimated_response_time: '24 hours'
    });

  } catch (error) {
    console.error('Car submission error:', error);
    return NextResponse.json(
      { error: 'Failed to submit car information. Please try again.' },
      { status: 500 }
    );
  }
}


